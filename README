# Minimal Webserver in Assembly (x86-64)
This project is a learning exercise to understand how webservers work
The source and inspiration comes from:
- https://pwn.college/ 
- https://youtu.be/MpsDNv-I8i0?si=UBZxxZSMCHWHr5c8

Tools I used:
- gcc as a compiler and a linker 

compiler: transforms x86-64 assembly (".s" files) into machine code (".o" object files)  
linker: transforms ".o" files into an ELF binary (Executable and Linkable Format), which can be run by the Linux kernel 

how I compiled: gcc -nostdlib -no-pie -o webserver webserver.s 

What is a webserver? 
A webserver is a Software running on  servers to processes HTTP(S) requests from clients.

A webserver contains:
- socket:
	Creates a communication endpoint between programs (client/server) to send and receive data.
	In C the syntax is "int socket(int domain, int type, int protocol);".
	domain = to determine if IPv4 or IPv6
	type = how to transport the data (SOCK_STREAM = TCP; SOCK_DGRAM = UDP)
	protocole = determine which transport protocole
- bind:
	Connects IP adresse with a port.
	In C the syntax is " int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);".
	sockfd = socket file descriptor (determine condition from file for the kernel)
	sockaddr = adress to bind the socket
	addrlen = lenght of address in bytes
- listen:
	Marks socket to accept the incomming connection.
	In C the syntax is "int listen(int sockfd, int backlog);".
	sockfd = socket file descriptor
	backlog = maximun amount of possible connections
- accept:
	Accepts a new connection from a client.
	In C the syntax is "int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);".
	sockfd = listening socket
	addr = store client's address (optional)
	addrlen = length of address (optional)
- read:
	Reads the client's HTTP request to find the data the client wants.
	In C the syntax is "ssize_t read(int fd, void *buf, size_t count);".
	fd = file descriptor form accept syscall for client connection
	buf = storage for request
	count = maximum numbers of bytes to read
- open:
	Opens the file that was requested from client.
	In C the syntax is "int open(const char *pathname, int flags, mode_t mode);".
	pathname = file name 
	flags = how to open file (permissions: O_RDONLY = read only ; O_WRONLY = write only ; ...)
	mode = only for create a file for the description of the file condition
- read:
	Reads the content of the file that was opened.
	Syntax same as before but storage is now used for content of file.
- write:
	Sends the content of the file to the client.
	In C the syntax is "ssize_t write(int fd, const void buf[.count], size_t count);".
	fd = file descriptor from accept syscall
	buffer = where write gets data / content
	count = bytes of content
- close:
	Terminates the process / webserver.
	In C the syntax is "int close(int fd);".

What is missing at my webserver?
Currently, the webserver processes only one HTTP request and then terminates.
Future improvements include adding multiprocessing using fork / join to handle multiple requests concurrently.

Somethink about Assembly (x86-64):
- register seqeunece: rax / rdi / rsi / rdx / r10 / r9 ...
- rax-register for syscall-numbers (I found them at my laptop here: /usr/include/x86_64-linux-gnu/asm/unistd_64.h)
- register r12 - r15 used as tmp variables 
